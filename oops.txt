Constructor:

A constructor is a special function in a class that is automatically called when an object is created.
In Python, the constructor is defined using the __init__() method.
It is used to initialize (set) the values or data of an object at the time of creation.
The first parameter of a constructor is always self, which refers to the current object.

__init__() is used for:

Assigning values to variables (attributes) of an object when it is created.

 Example:
class Student:
    def __init__(self, name, roll):
        self.name = name     # assigning value to object variable
        self.roll = roll     # assigning value to object variable

s1 = Student("Subhamoy", 54)
print(s1.name)   # Subhamoy
print(s1.roll)   # 54

The __init__() function always takes at least one parameter â€” self, which refers to the current object being created.
It allows the class to access and assign values to the objectâ€™s variables.
Using self, we can store data separately for each object.
 Example:
class Student:
    def __init__(self):
        print("Object created!")

s1 = Student()

In Python, self refers to the current object of the class.
You donâ€™t write self when creating an object because Python adds it automatically behind the scenes.
s1 = Student("Subhamoy", 24) **Note: donâ€™t need to write s1 = Student(self, "Subhamoy", 24) because self is added by Python automatically.

# class and object attrubute:

| Type                 | Defined Where                          | Accessed By                                 | Shared or Unique          |
| -------------------- | -------------------------------------- | ------------------------------------------- | ------------------------- |
| **Class Attribute**  | Inside class, **outside `__init__()`** | `ClassName.attribute` or `object.attribute` | ðŸ” Shared by all objects  |
| **Object Attribute** | Inside `__init__()` using `self.`      | `object.attribute`                          | ðŸŽ¯ Unique for each object |

A method in Python is a function that is written inside a class.
It is used to perform actions using the data and attributes of that class.
Every method has at least one parameter â€” self, which refers to the current object of the class.

class Student:
    def __init__(self, name):   # this is a method (constructor)
        self.name = name

    def greet(self):            # this is also a method
        print("Hello,", self.name)

# creating an object of the class
s1 = Student("Subhamoy")

# calling the method
s1.greet()

# def greet(self): â†’ is a method (a function inside the class).

# self refers to the current object (s1 here).

# When we call s1.greet(), it prints Hello, Subhamoy.


# Decorator:

#Input:
def decorator_func(func):
    def wrapper():
        print("ðŸš€ Starting function...")
        func()
        print("âœ… Function finished!")
    return wrapper

@decorator_func
def greet():
    print("Hello, Subhamoy!")

greet()

# Output:

ðŸš€ Starting function...
Hello, Subhamoy!
âœ… Function finished!

# Note â€“ Decorator in Python

A decorator is used to add extra functionality to a function without changing its actual code.
It works like a wrapper that can run some code before or after the main function runs.

When we write @decorator_func above a function, it tells Python that the function below should use that decorator.
So basically, it enhances the functionâ€™s behavior while keeping it clean and unchanged.

Example:

@decorator_func
def greet():
    print("Hello!")


Here, @decorator_func adds something extra to greet() â€” before or after it runs.

When we write:

def decorator_func(func):


ðŸ‘‰ that func is a parameter â€” it will receive the function you decorate.

So if you write:

@decorator_func
def greet():
    print("Hello!")


Then behind the scenes, Python does this:

greet = decorator_func(greet)


That means:

func â†’ becomes greet

So inside the decorator, func() â†’ actually means greet()

The 4 pillars of OOP (Object-Oriented Programming) are:

ðŸ§± Encapsulation

Meaning: Wrapping data (variables) and methods (functions) into a single unit â€” called a class.

Purpose: To protect data from being accessed directly; instead, itâ€™s accessed through methods.

Example:

class Student:
    def __init__(self, name):
        self.__name = name   # private variable
    
    def get_name(self):
        return self.__name


Here, __name is hidden (encapsulated) inside the class.

ðŸ§¬ Abstraction

Meaning: Hiding complex details and showing only the necessary parts.

Purpose: To make code simpler and easier to use.

Example:
When you call print(), you donâ€™t need to know how it prints â€” only that it prints.

ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Inheritance

Meaning: One class (child) can use properties and methods of another class (parent).

Purpose: To reuse code and avoid duplication.

Example:

class Animal:
    def speak(self):
        print("Sound")

class Dog(Animal):
    pass

d = Dog()
d.speak()  # Output: Sound


ðŸŒ€ Polymorphism

Meaning: "Many forms" â€” the same function name can behave differently based on the object that calls it.

Purpose: To make code more flexible.

Example:

class Dog:
    def speak(self):
        print("Bark")

class Cat:
    def speak(self):
        print("Meow")

for animal in [Dog(), Cat()]:
    animal.speak()


Both use the same speak() method but behave differently.

In short:
âž¡ï¸ Encapsulation â€“ Data hiding
âž¡ï¸ Abstraction â€“ Showing only essentials
âž¡ï¸ Inheritance â€“ Code reusability
âž¡ï¸ Polymorphism â€“ One name, many forms


Encapsulation means:

Keeping the data safe inside the class and allowing access to it only through specific methods (functions) instead of directly.

class Account:
    def __init__(self, balance):
        self.__balance = balance   # private data

    def deposit(self, amount):
        self.__balance += amount

    def get_balance(self):
        return self.__balance
Here:

__balance is hidden (safe) inside the class.

You can only access it using methods like deposit() or get_balance().

There are 3 types of variables in Python classes:
1. Public â†’ can be accessed by anyone
self.balance = 1000


âœ… Access directly (Public)

self.balance = 1000
print(acc.balance)   # âœ… Accessible directly


2ï¸âƒ£ Protected â†’ meant to be used only inside the class or its child classes (by convention)

self._balance = 1000


ðŸŸ¡ You can still access it like:

print(acc._balance)


But the single underscore _ means â€œplease donâ€™t touch this directlyâ€ â€” itâ€™s just a warning for developers, not a strict rule.

3ï¸âƒ£ Private â†’ truly hidden from outside the class

self.__balance = 1000


ðŸš« You canâ€™t access it directly using:

print(acc.__balance)   # âŒ Error


âœ… You must use a method:

print(acc.get_balance())   # âœ… Correct way

# inheritance -> inherit the properties from parent class to child class

# syntax -> another_class another_class_name(parent_class):

class House:
    def __init__(self):
        self.windows = True
        self.doors = True

class Building(House):
    # def __init__(self, room):
    def __init__(self):
        # super().__init__() â†’ calls House.__init__() â†’ sets windows=True, doors=True
        super().__init__()  # call House constructor
        self.color= "blue"
        
        
class BigRoom(Building):
    # def __init__(self,room, size):
    def __init__(self, size):
        super().__init__()
        self.size=size
# b1 = Building()

# print(b1.doors)
# print(b1.color)

# r1 = BigRoom(35)
# print(r1.doors)
# print(r1.size)
# print(r1.color)
        
# Multiple inheritance -> one child class got more than one parent class's properties

class Father:
    def skills(self):
        print("Can drive and repair things")

class Mother:
    def skills(self):
        print("Can cook and paint")

# Child inherits from BOTH Father and Mother
class Child(Father, Mother):
    def skills(self):
        # call both parentsâ€™ versions
        Father.skills(self)
        Mother.skills(self)
        print("Also good at coding!")

c = Child()
c.skills()

# Explanation:

# The Child class inherits from two parent classes â†’ Father and Mother.

# So this is multiple inheritance.

# You can call both parentsâ€™ methods (like shown above), or override them completely.

1. Normal method (with self)

When you create a normal method inside a class, it works for one object.

class Student:
    def __init__(self, name):
        self.name = name

    def show_name(self):
        print("Student name:", self.name)

s1 = Student("Subhamoy")
s1.show_name()     # works for one student


 Here, self means the object (like s1).
So it shows that studentâ€™s name only.

 2. Class method (with @classmethod)

Now, sometimes we want a method that works for the whole class, not just one object.
For that, we use @classmethod.

Letâ€™s see a simple example ðŸ‘‡

class Student:
    school_name = "Brainware University"   # common for all

    @classmethod
    def change_school(cls, new_name):
        cls.school_name = new_name


cls means the class itself (like Student).

@classmethod tells Python this method works for the class.

@property is used when you want to use a method like a variable.

Normally, when you make a method, you call it like this:

object.method()


But with @property, you can call it like a variable:

object.method   
# no brackets

# Polymorphism
It allows the same operator or function name to work in different ways depending on the data type or object it is used with.
# Example
print(10 + 5)       # Adds numbers
print("Hi" + "Bye") # Joins strings
