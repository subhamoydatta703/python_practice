Constructor:

A constructor is a special function in a class that is automatically called when an object is created.
In Python, the constructor is defined using the __init__() method.
It is used to initialize (set) the values or data of an object at the time of creation.
The first parameter of a constructor is always self, which refers to the current object.

__init__() is used for:

Assigning values to variables (attributes) of an object when it is created.

 Example:
class Student:
    def __init__(self, name, roll):
        self.name = name     # assigning value to object variable
        self.roll = roll     # assigning value to object variable

s1 = Student("Subhamoy", 54)
print(s1.name)   # Subhamoy
print(s1.roll)   # 54

The __init__() function always takes at least one parameter — self, which refers to the current object being created.
It allows the class to access and assign values to the object’s variables.
Using self, we can store data separately for each object.
 Example:
class Student:
    def __init__(self):
        print("Object created!")

s1 = Student()

In Python, self refers to the current object of the class.
You don’t write self when creating an object because Python adds it automatically behind the scenes.
s1 = Student("Subhamoy", 24) **Note: don’t need to write s1 = Student(self, "Subhamoy", 24) because self is added by Python automatically.

# class and object attrubute:

| Type                 | Defined Where                          | Accessed By                                 | Shared or Unique          |
| -------------------- | -------------------------------------- | ------------------------------------------- | ------------------------- |
| **Class Attribute**  | Inside class, **outside `__init__()`** | `ClassName.attribute` or `object.attribute` | 🔁 Shared by all objects  |
| **Object Attribute** | Inside `__init__()` using `self.`      | `object.attribute`                          | 🎯 Unique for each object |

A method in Python is a function that is written inside a class.
It is used to perform actions using the data and attributes of that class.
Every method has at least one parameter — self, which refers to the current object of the class.

class Student:
    def __init__(self, name):   # this is a method (constructor)
        self.name = name

    def greet(self):            # this is also a method
        print("Hello,", self.name)

# creating an object of the class
s1 = Student("Subhamoy")

# calling the method
s1.greet()

# def greet(self): → is a method (a function inside the class).

# self refers to the current object (s1 here).

# When we call s1.greet(), it prints Hello, Subhamoy.


# Decorator:

#Input:
def decorator_func(func):
    def wrapper():
        print("🚀 Starting function...")
        func()
        print("✅ Function finished!")
    return wrapper

@decorator_func
def greet():
    print("Hello, Subhamoy!")

greet()

# Output:

🚀 Starting function...
Hello, Subhamoy!
✅ Function finished!

# Note – Decorator in Python

A decorator is used to add extra functionality to a function without changing its actual code.
It works like a wrapper that can run some code before or after the main function runs.

When we write @decorator_func above a function, it tells Python that the function below should use that decorator.
So basically, it enhances the function’s behavior while keeping it clean and unchanged.

Example:

@decorator_func
def greet():
    print("Hello!")


Here, @decorator_func adds something extra to greet() — before or after it runs.

When we write:

def decorator_func(func):


👉 that func is a parameter — it will receive the function you decorate.

So if you write:

@decorator_func
def greet():
    print("Hello!")


Then behind the scenes, Python does this:

greet = decorator_func(greet)


That means:

func → becomes greet

So inside the decorator, func() → actually means greet()

The 4 pillars of OOP (Object-Oriented Programming) are:

🧱 Encapsulation

Meaning: Wrapping data (variables) and methods (functions) into a single unit — called a class.

Purpose: To protect data from being accessed directly; instead, it’s accessed through methods.

Example:

class Student:
    def __init__(self, name):
        self.__name = name   # private variable
    
    def get_name(self):
        return self.__name


Here, __name is hidden (encapsulated) inside the class.

🧬 Abstraction

Meaning: Hiding complex details and showing only the necessary parts.

Purpose: To make code simpler and easier to use.

Example:
When you call print(), you don’t need to know how it prints — only that it prints.

👨‍👩‍👧‍👦 Inheritance

Meaning: One class (child) can use properties and methods of another class (parent).

Purpose: To reuse code and avoid duplication.

Example:

class Animal:
    def speak(self):
        print("Sound")

class Dog(Animal):
    pass

d = Dog()
d.speak()  # Output: Sound


🌀 Polymorphism

Meaning: "Many forms" — the same function name can behave differently based on the object that calls it.

Purpose: To make code more flexible.

Example:

class Dog:
    def speak(self):
        print("Bark")

class Cat:
    def speak(self):
        print("Meow")

for animal in [Dog(), Cat()]:
    animal.speak()


Both use the same speak() method but behave differently.

In short:
➡️ Encapsulation – Data hiding
➡️ Abstraction – Showing only essentials
➡️ Inheritance – Code reusability
➡️ Polymorphism – One name, many forms


Encapsulation means:

Keeping the data safe inside the class and allowing access to it only through specific methods (functions) instead of directly.

class Account:
    def __init__(self, balance):
        self.__balance = balance   # private data

    def deposit(self, amount):
        self.__balance += amount

    def get_balance(self):
        return self.__balance
Here:

__balance is hidden (safe) inside the class.

You can only access it using methods like deposit() or get_balance().

There are 3 types of variables in Python classes:
1. Public → can be accessed by anyone
self.balance = 1000


✅ Access directly (Public)

self.balance = 1000
print(acc.balance)   # ✅ Accessible directly


2️⃣ Protected → meant to be used only inside the class or its child classes (by convention)

self._balance = 1000


🟡 You can still access it like:

print(acc._balance)


But the single underscore _ means “please don’t touch this directly” — it’s just a warning for developers, not a strict rule.

3️⃣ Private → truly hidden from outside the class

self.__balance = 1000


🚫 You can’t access it directly using:

print(acc.__balance)   # ❌ Error


✅ You must use a method:

print(acc.get_balance())   # ✅ Correct way
💬