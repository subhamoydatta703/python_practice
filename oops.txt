A constructor is a special function in a class that is automatically called when an object is created.
In Python, the constructor is defined using the __init__() method.
It is used to initialize (set) the values or data of an object at the time of creation.
The first parameter of a constructor is always self, which refers to the current object.

__init__() is used for:

Assigning values to variables (attributes) of an object when it is created.

 Example:
class Student:
    def __init__(self, name, roll):
        self.name = name     # assigning value to object variable
        self.roll = roll     # assigning value to object variable

s1 = Student("Subhamoy", 54)
print(s1.name)   # Subhamoy
print(s1.roll)   # 54

The __init__() function always takes at least one parameter ‚Äî self, which refers to the current object being created.
It allows the class to access and assign values to the object‚Äôs variables.
Using self, we can store data separately for each object.
 Example:
class Student:
    def __init__(self):
        print("Object created!")

s1 = Student()

In Python, self refers to the current object of the class.
You don‚Äôt write self when creating an object because Python adds it automatically behind the scenes.
s1 = Student("Subhamoy", 24) **Note: don‚Äôt need to write s1 = Student(self, "Subhamoy", 24) because self is added by Python automatically.

# class and object attrubute:

| Type                 | Defined Where                          | Accessed By                                 | Shared or Unique          |
| -------------------- | -------------------------------------- | ------------------------------------------- | ------------------------- |
| **Class Attribute**  | Inside class, **outside `__init__()`** | `ClassName.attribute` or `object.attribute` | üîÅ Shared by all objects  |
| **Object Attribute** | Inside `__init__()` using `self.`      | `object.attribute`                          | üéØ Unique for each object |

A method in Python is a function that is written inside a class.
It is used to perform actions using the data and attributes of that class.
Every method has at least one parameter ‚Äî self, which refers to the current object of the class.

class Student:
    def __init__(self, name):   # this is a method (constructor)
        self.name = name

    def greet(self):            # this is also a method
        print("Hello,", self.name)

# creating an object of the class
s1 = Student("Subhamoy")

# calling the method
s1.greet()

# def greet(self): ‚Üí is a method (a function inside the class).

# self refers to the current object (s1 here).

# When we call s1.greet(), it prints Hello, Subhamoy.


# Decorator:

#Input:
def decorator_func(func):
    def wrapper():
        print("üöÄ Starting function...")
        func()
        print("‚úÖ Function finished!")
    return wrapper

@decorator_func
def greet():
    print("Hello, Subhamoy!")

greet()

# Output:

üöÄ Starting function...
Hello, Subhamoy!
‚úÖ Function finished!

# Note ‚Äì Decorator in Python

A decorator is used to add extra functionality to a function without changing its actual code.
It works like a wrapper that can run some code before or after the main function runs.

When we write @decorator_func above a function, it tells Python that the function below should use that decorator.
So basically, it enhances the function‚Äôs behavior while keeping it clean and unchanged.

Example:

@decorator_func
def greet():
    print("Hello!")


Here, @decorator_func adds something extra to greet() ‚Äî before or after it runs.

When we write:

def decorator_func(func):


üëâ that func is a parameter ‚Äî it will receive the function you decorate.

So if you write:

@decorator_func
def greet():
    print("Hello!")


Then behind the scenes, Python does this:

greet = decorator_func(greet)


That means:

func ‚Üí becomes greet

So inside the decorator, func() ‚Üí actually means greet()