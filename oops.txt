Constructor:

A constructor is a special function in a class that is automatically called when an object is created.
In Python, the constructor is defined using the __init__() method.
It is used to initialize (set) the values or data of an object at the time of creation.
The first parameter of a constructor is always self, which refers to the current object.

__init__() is used for:

Assigning values to variables (attributes) of an object when it is created.

 Example:
class Student:
    def __init__(self, name, roll):
        self.name = name     # assigning value to object variable
        self.roll = roll     # assigning value to object variable

s1 = Student("Subhamoy", 54)
print(s1.name)   # Subhamoy
print(s1.roll)   # 54

The __init__() function always takes at least one parameter â€” self, which refers to the current object being created.
It allows the class to access and assign values to the objectâ€™s variables.
Using self, we can store data separately for each object.
 Example:
class Student:
    def __init__(self):
        print("Object created!")

s1 = Student()

In Python, self refers to the current object of the class.
You donâ€™t write self when creating an object because Python adds it automatically behind the scenes.
s1 = Student("Subhamoy", 24) **Note: donâ€™t need to write s1 = Student(self, "Subhamoy", 24) because self is added by Python automatically.

# class and object attrubute:

| Type                 | Defined Where                          | Accessed By                                 | Shared or Unique          |
| -------------------- | -------------------------------------- | ------------------------------------------- | ------------------------- |
| **Class Attribute**  | Inside class, **outside `__init__()`** | `ClassName.attribute` or `object.attribute` | ğŸ” Shared by all objects  |
| **Object Attribute** | Inside `__init__()` using `self.`      | `object.attribute`                          | ğŸ¯ Unique for each object |

A method in Python is a function that is written inside a class.
It is used to perform actions using the data and attributes of that class.
Every method has at least one parameter â€” self, which refers to the current object of the class.

class Student:
    def __init__(self, name):   # this is a method (constructor)
        self.name = name

    def greet(self):            # this is also a method
        print("Hello,", self.name)

# creating an object of the class
s1 = Student("Subhamoy")

# calling the method
s1.greet()

# def greet(self): â†’ is a method (a function inside the class).

# self refers to the current object (s1 here).

# When we call s1.greet(), it prints Hello, Subhamoy.


# Decorator:

#Input:
def decorator_func(func):
    def wrapper():
        print("ğŸš€ Starting function...")
        func()
        print("âœ… Function finished!")
    return wrapper

@decorator_func
def greet():
    print("Hello, Subhamoy!")

greet()

# Output:

ğŸš€ Starting function...
Hello, Subhamoy!
âœ… Function finished!

# Note â€“ Decorator in Python

A decorator is used to add extra functionality to a function without changing its actual code.
It works like a wrapper that can run some code before or after the main function runs.

When we write @decorator_func above a function, it tells Python that the function below should use that decorator.
So basically, it enhances the functionâ€™s behavior while keeping it clean and unchanged.

Example:

@decorator_func
def greet():
    print("Hello!")


Here, @decorator_func adds something extra to greet() â€” before or after it runs.

When we write:

def decorator_func(func):


ğŸ‘‰ that func is a parameter â€” it will receive the function you decorate.

So if you write:

@decorator_func
def greet():
    print("Hello!")


Then behind the scenes, Python does this:

greet = decorator_func(greet)


That means:

func â†’ becomes greet

So inside the decorator, func() â†’ actually means greet()

The 4 pillars of OOP (Object-Oriented Programming) are:

ğŸ§± Encapsulation

Meaning: Wrapping data (variables) and methods (functions) into a single unit â€” called a class.

Purpose: To protect data from being accessed directly; instead, itâ€™s accessed through methods.

Example:

class Student:
    def __init__(self, name):
        self.__name = name   # private variable
    
    def get_name(self):
        return self.__name


Here, __name is hidden (encapsulated) inside the class.

ğŸ§¬ Abstraction

Meaning: Hiding complex details and showing only the necessary parts.

Purpose: To make code simpler and easier to use.

Example:
When you call print(), you donâ€™t need to know how it prints â€” only that it prints.

ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ Inheritance

Meaning: One class (child) can use properties and methods of another class (parent).

Purpose: To reuse code and avoid duplication.

Example:

class Animal:
    def speak(self):
        print("Sound")

class Dog(Animal):
    pass

d = Dog()
d.speak()  # Output: Sound


ğŸŒ€ Polymorphism

Meaning: "Many forms" â€” the same function name can behave differently based on the object that calls it.

Purpose: To make code more flexible.

Example:

class Dog:
    def speak(self):
        print("Bark")

class Cat:
    def speak(self):
        print("Meow")

for animal in [Dog(), Cat()]:
    animal.speak()


Both use the same speak() method but behave differently.

In short:
â¡ï¸ Encapsulation â€“ Data hiding
â¡ï¸ Abstraction â€“ Showing only essentials
â¡ï¸ Inheritance â€“ Code reusability
â¡ï¸ Polymorphism â€“ One name, many forms


Encapsulation means:

Keeping the data safe inside the class and allowing access to it only through specific methods (functions) instead of directly.

class Account:
    def __init__(self, balance):
        self.__balance = balance   # private data

    def deposit(self, amount):
        self.__balance += amount

    def get_balance(self):
        return self.__balance
Here:

__balance is hidden (safe) inside the class.

You can only access it using methods like deposit() or get_balance().

There are 3 types of variables in Python classes:
1. Public â†’ can be accessed by anyone
self.balance = 1000


âœ… Access directly (Public)

self.balance = 1000
print(acc.balance)   # âœ… Accessible directly


2ï¸âƒ£ Protected â†’ meant to be used only inside the class or its child classes (by convention)

self._balance = 1000


ğŸŸ¡ You can still access it like:

print(acc._balance)


But the single underscore _ means â€œplease donâ€™t touch this directlyâ€ â€” itâ€™s just a warning for developers, not a strict rule.

3ï¸âƒ£ Private â†’ truly hidden from outside the class

self.__balance = 1000


ğŸš« You canâ€™t access it directly using:

print(acc.__balance)   # âŒ Error


âœ… You must use a method:

print(acc.get_balance())   # âœ… Correct way
ğŸ’¬